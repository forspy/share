#include <stdio.h>

int main()
{
	int n=100;//4个字节，float 4 个字节 double 8个字节
    int m=101;
	int*n1 = &n;
	int*m1 = &m;
	printf("%d\n", &n);//输出结果为9435068
	printf("%p\n", &n);//十六进制00AFF718,&为求地址符，指针（地址）的标准化输出格式%p
	printf("%d\n", &m);//输出结果为9435056（下一个开的内存地址比上一个少12）
	//变量在栈区存储，地址按照从大到小排列，变量之间的间隔是8个字节就是两个int位，所以变量的指针（首地址）差了3个int位,用指针操作变量就可以用指针操作内存
	int*pp = &n;
	printf("pp:%d\n", pp);
	printf("n:%d\n", *pp);
	printf("m新:%d\n", *(pp-3));//?待解决,*()操作的类型只能是指针只操作地址的方法需要实践，已解决：*（指针（地址））反应的就是这个变量
	
	printf("m:%d\n", *(n1 - 3));
	*(pp) = 10086;//解引用n的地址
	printf("n:%d\n", n);
	int*p = &n;//用指针p来保存n的地址（首地址）,称p为指针变量
	int array[5] = { 1,2,3,4,5 };
	int i;
	for (i = 0; i < 5; ++i)//无论是i++还是++i，array[i]都是从0开始，即++过程在for循环末尾生效
	{
		printf("第%d个是%d\n",i, array[i]);
	}
	int *p1 = &array[0];//指针指向数组的第一个元素
	//数组的栈堆储存是紧密排列的
	char hello[] = "hello";
	char world[] = "world";
	//char *p2="hello!";
	char *p2[2];//指针数组
	p2[0] = hello;
	p2[1] = world;
	printf("测试%s\n", p2[0]);//字符串输出
	printf("测试%s\n", *(p2+1));//字符串输出
	printf("数组第3个元素是%d\n", *((int*)p1 + 2));//*(p1+2)也行
	//定义一个二维数组
	int array2[5][5] =
	{
		{  1, 2, 3, 4, 5 },
		{ 11,12,13,14,15 },
		{ 21,22,23,24,25 },
		{ 31,32,33,34,35 },
		{ 41,42,43,44,45 },
	};//实质在内存上开辟的是一维数组00(1) 01(2) 02(3) 03(4) 04(5) 10(6) 11(7) 12(8) 13(9) 14(10) 20(11) 21(12)..
	int* a2 = &array2[0][0];
	printf("%d\n", array2[1][3]);//14
	printf("%d\n", *(a2+1*5+3));//二维数组的指针操作
	int(*pa)[5] = &array;//定义一个指向‘数组’的指针？待解决，已解决：是的，得到一个数组指针,pa为单个变量，指向数组的首地址
	printf("%d\n", *((int*)(pa+1)-2));//【解法一】得到4：对数组进行  指针运算，解引用的方法写出数组指针中的某个数 【标准写法】
	printf("%d\n", *((int*)pa));//（int*）pa会得到pa指针组的第一个元素的位置
	printf("%d\n", *((int*)pa + 3));//【解法二】:得到4，得到首元素地址往后移动，，【标准写法】
	printf("%d\n", *(*pa + 3));//【解法三】：等价对于指针数组来说*pa相当于得到

	//指针标准用法
	int x = 1, y = 2, z[10];
	int *ip;//ip是指向int类型的指针
	ip = &x;//ip指向x
	y = *ip;//y的值变为1
	*ip = 0;//x的值变为0
	ip = &z[0];//ip指向数组z[0]
	int *iq;
	iq = ip;//现在iq也指向ip所指的变量
	char kk[] = "hello world";
	
}
